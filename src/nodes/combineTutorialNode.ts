import fs from "fs";
import path from "path";
import { Node } from "pocketflow";

import { SharedStore } from "../types";

interface ChapterFile {
    filename: string;
    content: string;
}

interface CombineTutorialNodePrepResult {
    outputPath: string;
    indexContent: string;
    chapterFiles: ChapterFile[];
}

export default class CombineTutorialNode extends Node<SharedStore> {
    async prep(shared: SharedStore): Promise<CombineTutorialNodePrepResult> {
        const projectName = shared.projectName;
        const outputBaseDir = shared.outputDir;
        const outputPath = path.join(outputBaseDir, projectName || "tutorial");

        // 获取可能已翻译的数据
        const relationshipsData = shared.relationships; // {"summary": str, "details": [{"from": int, "to": int, "label": str}]} -> summary/label 可能已翻译
        const chapterOrder = shared.chapterOrder; // 索引
        const abstractions = shared.abstractions; // 字典列表 -> name/description 可能已翻译
        const chaptersContent = shared.chapters; // 字符串列表 -> 内容可能已翻译

        // --- 生成 Mermaid 图表 ---
        const mermaidLines: string[] = ["flowchart TD"];
        // 为每个抽象概念添加节点，使用可能已翻译的名称
        for (let i = 0; i < abstractions.length; i++) {
            const nodeId = `A${i}`;
            // 使用可能已翻译的名称，为 Mermaid ID 和标签进行清理
            const sanitizedName = abstractions[i].name.replace(/"/g, "");
            const nodeLabel = sanitizedName; // 仅使用清理后的名称
            mermaidLines.push(`    ${nodeId}["${nodeLabel}"]`); // 节点标签使用可能已翻译的名称
        }

        // 为关系添加边，使用可能已翻译的标签
        for (const rel of relationshipsData.details) {
            const fromNodeId = `A${rel.from}`;
            const toNodeId = `A${rel.to}`;
            // 使用可能已翻译的标签，进行清理
            let edgeLabel = rel.label.replace(/"/g, "").replace(/\n/g, " "); // 基本清理
            const maxLabelLen = 30;
            if (edgeLabel.length > maxLabelLen) {
                edgeLabel = edgeLabel.substring(0, maxLabelLen - 3) + "...";
            }
            mermaidLines.push(`    ${fromNodeId} -- "${edgeLabel}" --> ${toNodeId}`); // 边标签使用可能已翻译的标签
        }

        const mermaidDiagram = mermaidLines.join("\n");
        // --- Mermaid 结束 ---

        // --- 准备 index.md 内容 ---
        let indexContent = `# Tutorial: ${projectName}\n\n`;
        indexContent += `${relationshipsData.summary}\n\n`; // 直接使用可能已翻译的摘要
        // 保持固定字符串为英文

        // 添加关系的 Mermaid 图表（图表本身使用可能已翻译的名称/标签）
        indexContent += "```mermaid\n";
        indexContent += mermaidDiagram + "\n";
        indexContent += "```\n\n";

        // 保持固定字符串为英文
        indexContent += `## Chapters\n\n`;

        const chapterFiles: ChapterFile[] = [];
        // 根据确定的顺序生成章节链接，使用可能已翻译的名称
        for (let i = 0; i < chapterOrder.length; i++) {
            const abstractionIndex = chapterOrder[i];
            // 确保索引有效且我们有对应的内容
            if (0 <= abstractionIndex && abstractionIndex < abstractions.length && i < chaptersContent.length) {
                const abstractionName = abstractions[abstractionIndex].name; // 可能已翻译的名称
                // 为文件名清理可能已翻译的名称
                const safeName = abstractionName.replace(/[^a-zA-Z0-9]/g, "_").toLowerCase();
                const filename = `${(i + 1).toString().padStart(2, "0")}_${safeName}.md`;
                indexContent += `${i + 1}. [${abstractionName}](${filename})\n`; // 在链接文本中使用可能已翻译的名称

                // 为章节内容添加归属（使用英文固定字符串）
                let chapterContent = chaptersContent[i]; // 可能已翻译的内容
                if (!chapterContent.endsWith("\n\n")) {
                    chapterContent += "\n\n";
                }
                // 保持固定字符串为英文
                chapterContent += `---\n\nGenerated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)`;

                // 存储文件名和对应内容
                chapterFiles.push({ filename, content: chapterContent });
            } else {
                console.log(
                    `Warning: Mismatch between chapter order, abstractions, or content at index ${i} (abstraction index ${abstractionIndex}). Skipping file generation for this entry.`,
                );
            }
        }

        // 为索引内容添加归属（使用英文固定字符串）
        indexContent += `\n\n---\n\nGenerated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)`;

        return {
            outputPath,
            indexContent,
            chapterFiles, // 列表 {"filename": str, "content": str}
        };
    }

    /**
     * 执行教程生成
     */
    async exec(prepRes: CombineTutorialNodePrepResult): Promise<string> {
        const outputPath = prepRes.outputPath;
        const indexContent = prepRes.indexContent;
        const chapterFiles = prepRes.chapterFiles;

        console.log(`Combining tutorial into directory: ${outputPath}`);
        // 依赖 Node 的内置重试/回退
        fs.mkdirSync(outputPath, { recursive: true });

        // 写入 index.md
        const indexFilepath = path.join(outputPath, "index.md");
        fs.writeFileSync(indexFilepath, indexContent, { encoding: "utf-8" });
        console.log(`  - Wrote ${indexFilepath}`);

        // 写入章节文件
        for (const chapterInfo of chapterFiles) {
            const chapterFilepath = path.join(outputPath, chapterInfo.filename);
            fs.writeFileSync(chapterFilepath, chapterInfo.content, { encoding: "utf-8" });
            console.log(`  - Wrote ${chapterFilepath}`);
        }

        return outputPath; // 返回最终路径
    }

    /**
     * 处理后续操作
     */
    async post(
        shared: SharedStore,
        prepRes: CombineTutorialNodePrepResult,
        execRes: string,
    ): Promise<string | undefined> {
        shared.finalOutputDir = execRes; // 存储输出路径
        console.log(`\nTutorial generation complete! Files are in: ${execRes}`);
        return undefined;
    }
}
